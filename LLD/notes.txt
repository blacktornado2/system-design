How to write good code:
1. Readable
2. Extensibility
3. Correctness

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


1. TypeScript fundamentals(https://www.w3schools.com/typescript/index.php)
2. OOP Fundamentals
3. KISS, YAGNI, SOC & DRY Principles
4. SOLID Principles(https://cloudaffle.com/series/solid-design-principles/what-is-solid/)
5. Design Patterns(Factory, Abstract Factory, Singleton, Observer, Strategy)
6. UML diagram
 - https://bytebytego.com/guides/a-cheatsheet-for-uml-class-diagrams/
 - https://www.lucidchart.com/pages/uml-class-diagram
 - https://khalilstemmler.com/articles/uml-cheatsheet/
7. Some good problems


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# SOLID principles

S - Single Responsibility Principle
O - Open/Closed Principle(Open for extension, Closed for modification)
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle

Advantages of SOLID principles:
- Avoid Duplicate code
- Easy to maintain and extend
- Easy to understand
- Flexible software
- Reduce Complexity


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Design Patterns


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Problems:
1. Design notify-me button functionality
2. Design Pizza billing system
3. Design Parking lot
4. Design Snake and Ladder game
5. Design Elevator system
6. Design Logging system
7. Design Tic-tac-toe game
8. Design Book my Show and concurrency handling
9. Design Vending machine
10. Design ATM

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Framework
1. Clarify and Scope Requirements
2. Define Key Use-cases and APIs
3. Data Model & Persistence
4. Core Class Design
5. Identify & Apply Design Patterns
6. Sequence for the MAIN flow
7. Concurrency & consistency
8. Edge cases & Error handling
9. Coding
10. Extensions & Scaling